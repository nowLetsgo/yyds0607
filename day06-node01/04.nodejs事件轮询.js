/* 
    nodeJS的事件轮询：
        - JavaScript是单线程的， 那么nodejs是如何做到非阻塞呢，在nodejs内部使用了第三方库libuv，nodejs会把IO，文件读取等异步操作交由他处理，而nodejs主线程可以继续去处理其他的事情。
        - libuv会开启不同的线程去处理这些异步操作，处理完后，会把异步操作的回调函数放到nodejs的轮询队列中，nodejs会在适当的时候处理轮询队列中的回调函数，从而实现非阻塞。
        - 事件轮询机制分为六个阶段，每个阶段都有一个 FIFO（先进先出） 队列来执行回调
        - 当事件轮询进入到每个阶段的回调队列的时候，此时会把当前的队列中的回调执行完成，或者最大回调数用尽，则进入下一个阶段执行

        事件轮询的6个阶段
            - timers阶段
                - timers阶段用来处理setTimeout() 和 setInterval() 的回调函数
                - 并不是一定是第一个执行定时器的回调函数，因为当事件轮询到达这个阶段的时候，定时器的回调函数可能还没有被放入回调队列中
                - 当这个阶段的回调数用尽或者回调函数执行完毕，则会进入下一个阶段

            - pending callbacks阶段
                - 这个阶段用来处理系统操作的回调函数（可以忽略）

            - idle prepare阶段
                - 此阶段是仅供nodejs内部操作调用，忽略

            - poll阶段
                - 这个阶段主要用来处理如IO操作，网络请求等异步操作
                - 当进入poll阶段时候，如果存在回调函数，则执行完回调函数之后，会跳过当前阶段，执行下一个阶段
                - 当进入poll阶段时候，如果poll阶段为空，则会选择在此地一直等待。除非第一个阶段中出现了定时器的回调函数或者说还设置有setImmediate没有执行，则会立即进入下一个阶段

            - check阶段
                - 这个阶段用来处理setImmediate的回调函数
                - 当处理完成之后会进入下个阶段（如果poll阶段为空，check阶段存在回调函数，则立即跳出poll阶段 执行check阶段）

            - close callbacks阶段
                - 这个阶段用来处理如socket的close事件（目前暂时不考虑）


*/